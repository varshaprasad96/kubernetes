//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright YEAR The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by kcp code-generator. DO NOT EDIT.

package v1

import (
	"context"
	"fmt"
	kcp "github.com/kcp-dev/apimachinery/pkg/client"
	"github.com/kcp-dev/logicalcluster"
	rbacapiv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	rbacapplyv1 "k8s.io/client-go/applyconfigurations/rbac/v1"
	rbacv1 "k8s.io/client-go/kubernetes/typed/rbac/v1"
	"k8s.io/client-go/rest"
)

// WrappedRbacV1 wraps the client interface with a
// logical cluster.
type WrappedRbacV1 struct {
	cluster  logicalcluster.Name
	delegate rbacv1.RbacV1Interface
}

// New creates a WrappedRbacV1 with the given logical cluster and client interface.
func New(cluster logicalcluster.Name, delegate rbacv1.RbacV1Interface) *WrappedRbacV1 {
	return &WrappedRbacV1{cluster: cluster, delegate: delegate}
}

// RESTClient returns the underlying RESTClient.
func (w *WrappedRbacV1) RESTClient() rest.Interface {
	return w.delegate.RESTClient()
}

// WrappedRbacV1 contains the wrapped logical cluster and interface.
func (w *WrappedRbacV1) ClusterRoles() rbacv1.ClusterRoleInterface {
	return &wrappedClusterRole{
		cluster:  w.cluster,
		delegate: w.delegate.ClusterRoles(),
	}
}

type wrappedClusterRole struct {
	cluster  logicalcluster.Name
	delegate rbacv1.ClusterRoleInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedClusterRole. It errors when
// there is a mismatch.
func (w *wrappedClusterRole) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ClusterRoleInterface.
func (w *wrappedClusterRole) Get(ctx context.Context, name string, opts metav1.GetOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ClusterRoleInterface.
func (w *wrappedClusterRole) List(ctx context.Context, opts metav1.ListOptions) (*rbacapiv1.ClusterRoleList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ClusterRoleInterface.
func (w *wrappedClusterRole) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ClusterRoleInterface.
func (w *wrappedClusterRole) Create(ctx context.Context, clusterRole *rbacapiv1.ClusterRole, opts metav1.CreateOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, clusterRole, opts)
}

// Update implements ClusterRoleInterface.
func (w *wrappedClusterRole) Update(ctx context.Context, clusterRole *rbacapiv1.ClusterRole, opts metav1.UpdateOptions) (*rbacapiv1.ClusterRole, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, clusterRole, opts)
}

// Delete implements ClusterRoleInterface.
func (w *wrappedClusterRole) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ClusterRoleInterface.
func (w *wrappedClusterRole) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ClusterRoleInterface.
func (w *wrappedClusterRole) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *rbacapiv1.ClusterRole, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ClusterRoleInterface.
func (w *wrappedClusterRole) Apply(ctx context.Context, clusterRole *rbacapplyv1.ClusterRoleApplyConfiguration, opts metav1.ApplyOptions) (result *rbacapiv1.ClusterRole, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, clusterRole, opts)
}

// WrappedRbacV1 contains the wrapped logical cluster and interface.
func (w *WrappedRbacV1) ClusterRoleBindings() rbacv1.ClusterRoleBindingInterface {
	return &wrappedClusterRoleBinding{
		cluster:  w.cluster,
		delegate: w.delegate.ClusterRoleBindings(),
	}
}

type wrappedClusterRoleBinding struct {
	cluster  logicalcluster.Name
	delegate rbacv1.ClusterRoleBindingInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedClusterRoleBinding. It errors when
// there is a mismatch.
func (w *wrappedClusterRoleBinding) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Get(ctx context.Context, name string, opts metav1.GetOptions) (*rbacapiv1.ClusterRoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) List(ctx context.Context, opts metav1.ListOptions) (*rbacapiv1.ClusterRoleBindingList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Create(ctx context.Context, clusterRoleBinding *rbacapiv1.ClusterRoleBinding, opts metav1.CreateOptions) (*rbacapiv1.ClusterRoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, clusterRoleBinding, opts)
}

// Update implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Update(ctx context.Context, clusterRoleBinding *rbacapiv1.ClusterRoleBinding, opts metav1.UpdateOptions) (*rbacapiv1.ClusterRoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, clusterRoleBinding, opts)
}

// Delete implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *rbacapiv1.ClusterRoleBinding, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ClusterRoleBindingInterface.
func (w *wrappedClusterRoleBinding) Apply(ctx context.Context, clusterRoleBinding *rbacapplyv1.ClusterRoleBindingApplyConfiguration, opts metav1.ApplyOptions) (result *rbacapiv1.ClusterRoleBinding, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, clusterRoleBinding, opts)
}

// WrappedRbacV1 contains the wrapped logical cluster and interface.
func (w *WrappedRbacV1) Roles(namespace string) rbacv1.RoleInterface {
	return &wrappedRole{
		cluster:  w.cluster,
		delegate: w.delegate.Roles(namespace),
	}
}

type wrappedRole struct {
	cluster  logicalcluster.Name
	delegate rbacv1.RoleInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedRole. It errors when
// there is a mismatch.
func (w *wrappedRole) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements RoleInterface.
func (w *wrappedRole) Get(ctx context.Context, name string, opts metav1.GetOptions) (*rbacapiv1.Role, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements RoleInterface.
func (w *wrappedRole) List(ctx context.Context, opts metav1.ListOptions) (*rbacapiv1.RoleList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements RoleInterface.
func (w *wrappedRole) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements RoleInterface.
func (w *wrappedRole) Create(ctx context.Context, role *rbacapiv1.Role, opts metav1.CreateOptions) (*rbacapiv1.Role, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, role, opts)
}

// Update implements RoleInterface.
func (w *wrappedRole) Update(ctx context.Context, role *rbacapiv1.Role, opts metav1.UpdateOptions) (*rbacapiv1.Role, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, role, opts)
}

// Delete implements RoleInterface.
func (w *wrappedRole) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements RoleInterface.
func (w *wrappedRole) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements RoleInterface.
func (w *wrappedRole) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *rbacapiv1.Role, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements RoleInterface.
func (w *wrappedRole) Apply(ctx context.Context, role *rbacapplyv1.RoleApplyConfiguration, opts metav1.ApplyOptions) (result *rbacapiv1.Role, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, role, opts)
}

// WrappedRbacV1 contains the wrapped logical cluster and interface.
func (w *WrappedRbacV1) RoleBindings(namespace string) rbacv1.RoleBindingInterface {
	return &wrappedRoleBinding{
		cluster:  w.cluster,
		delegate: w.delegate.RoleBindings(namespace),
	}
}

type wrappedRoleBinding struct {
	cluster  logicalcluster.Name
	delegate rbacv1.RoleBindingInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedRoleBinding. It errors when
// there is a mismatch.
func (w *wrappedRoleBinding) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements RoleBindingInterface.
func (w *wrappedRoleBinding) Get(ctx context.Context, name string, opts metav1.GetOptions) (*rbacapiv1.RoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements RoleBindingInterface.
func (w *wrappedRoleBinding) List(ctx context.Context, opts metav1.ListOptions) (*rbacapiv1.RoleBindingList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements RoleBindingInterface.
func (w *wrappedRoleBinding) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements RoleBindingInterface.
func (w *wrappedRoleBinding) Create(ctx context.Context, roleBinding *rbacapiv1.RoleBinding, opts metav1.CreateOptions) (*rbacapiv1.RoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, roleBinding, opts)
}

// Update implements RoleBindingInterface.
func (w *wrappedRoleBinding) Update(ctx context.Context, roleBinding *rbacapiv1.RoleBinding, opts metav1.UpdateOptions) (*rbacapiv1.RoleBinding, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, roleBinding, opts)
}

// Delete implements RoleBindingInterface.
func (w *wrappedRoleBinding) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements RoleBindingInterface.
func (w *wrappedRoleBinding) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements RoleBindingInterface.
func (w *wrappedRoleBinding) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *rbacapiv1.RoleBinding, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements RoleBindingInterface.
func (w *wrappedRoleBinding) Apply(ctx context.Context, roleBinding *rbacapplyv1.RoleBindingApplyConfiguration, opts metav1.ApplyOptions) (result *rbacapiv1.RoleBinding, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, roleBinding, opts)
}
