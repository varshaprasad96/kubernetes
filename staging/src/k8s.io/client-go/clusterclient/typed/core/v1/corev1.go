//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright YEAR The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by kcp code-generator. DO NOT EDIT.

package v1

import (
	"context"
	"fmt"
	kcp "github.com/kcp-dev/apimachinery/pkg/client"
	"github.com/kcp-dev/logicalcluster"
	tokenrequestapi "k8s.io/api/authentication/v1"
	scaleapi "k8s.io/api/autoscaling/v1"
	coreapiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	coreapplyv1 "k8s.io/client-go/applyconfigurations/core/v1"
	corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
	"k8s.io/client-go/rest"
)

// WrappedCoreV1 wraps the client interface with a
// logical cluster.
type WrappedCoreV1 struct {
	cluster  logicalcluster.Name
	delegate corev1.CoreV1Interface
}

// New creates a WrappedCoreV1 with the given logical cluster and client interface.
func New(cluster logicalcluster.Name, delegate corev1.CoreV1Interface) *WrappedCoreV1 {
	return &WrappedCoreV1{cluster: cluster, delegate: delegate}
}

// RESTClient returns the underlying RESTClient.
func (w *WrappedCoreV1) RESTClient() rest.Interface {
	return w.delegate.RESTClient()
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) ComponentStatuses() corev1.ComponentStatusInterface {
	return &wrappedComponentStatus{
		cluster:  w.cluster,
		delegate: w.delegate.ComponentStatuses(),
	}
}

type wrappedComponentStatus struct {
	cluster  logicalcluster.Name
	delegate corev1.ComponentStatusInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedComponentStatus. It errors when
// there is a mismatch.
func (w *wrappedComponentStatus) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.ComponentStatus, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ComponentStatusInterface.
func (w *wrappedComponentStatus) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ComponentStatusList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Create(ctx context.Context, componentStatus *coreapiv1.ComponentStatus, opts metav1.CreateOptions) (*coreapiv1.ComponentStatus, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, componentStatus, opts)
}

// Update implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Update(ctx context.Context, componentStatus *coreapiv1.ComponentStatus, opts metav1.UpdateOptions) (*coreapiv1.ComponentStatus, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, componentStatus, opts)
}

// Delete implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ComponentStatusInterface.
func (w *wrappedComponentStatus) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.ComponentStatus, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ComponentStatusInterface.
func (w *wrappedComponentStatus) Apply(ctx context.Context, componentStatus *coreapplyv1.ComponentStatusApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ComponentStatus, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, componentStatus, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) ConfigMaps(namespace string) corev1.ConfigMapInterface {
	return &wrappedConfigMap{
		cluster:  w.cluster,
		delegate: w.delegate.ConfigMaps(namespace),
	}
}

type wrappedConfigMap struct {
	cluster  logicalcluster.Name
	delegate corev1.ConfigMapInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedConfigMap. It errors when
// there is a mismatch.
func (w *wrappedConfigMap) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ConfigMapInterface.
func (w *wrappedConfigMap) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.ConfigMap, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ConfigMapInterface.
func (w *wrappedConfigMap) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ConfigMapList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ConfigMapInterface.
func (w *wrappedConfigMap) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ConfigMapInterface.
func (w *wrappedConfigMap) Create(ctx context.Context, configMap *coreapiv1.ConfigMap, opts metav1.CreateOptions) (*coreapiv1.ConfigMap, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, configMap, opts)
}

// Update implements ConfigMapInterface.
func (w *wrappedConfigMap) Update(ctx context.Context, configMap *coreapiv1.ConfigMap, opts metav1.UpdateOptions) (*coreapiv1.ConfigMap, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, configMap, opts)
}

// Delete implements ConfigMapInterface.
func (w *wrappedConfigMap) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ConfigMapInterface.
func (w *wrappedConfigMap) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ConfigMapInterface.
func (w *wrappedConfigMap) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.ConfigMap, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ConfigMapInterface.
func (w *wrappedConfigMap) Apply(ctx context.Context, configMap *coreapplyv1.ConfigMapApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ConfigMap, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, configMap, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Endpoints(namespace string) corev1.EndpointsInterface {
	return &wrappedEndpoints{
		cluster:  w.cluster,
		delegate: w.delegate.Endpoints(namespace),
	}
}

type wrappedEndpoints struct {
	cluster  logicalcluster.Name
	delegate corev1.EndpointsInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedEndpoints. It errors when
// there is a mismatch.
func (w *wrappedEndpoints) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements EndpointsInterface.
func (w *wrappedEndpoints) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Endpoints, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements EndpointsInterface.
func (w *wrappedEndpoints) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.EndpointsList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements EndpointsInterface.
func (w *wrappedEndpoints) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements EndpointsInterface.
func (w *wrappedEndpoints) Create(ctx context.Context, endpoints *coreapiv1.Endpoints, opts metav1.CreateOptions) (*coreapiv1.Endpoints, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, endpoints, opts)
}

// Update implements EndpointsInterface.
func (w *wrappedEndpoints) Update(ctx context.Context, endpoints *coreapiv1.Endpoints, opts metav1.UpdateOptions) (*coreapiv1.Endpoints, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, endpoints, opts)
}

// Delete implements EndpointsInterface.
func (w *wrappedEndpoints) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements EndpointsInterface.
func (w *wrappedEndpoints) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements EndpointsInterface.
func (w *wrappedEndpoints) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Endpoints, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements EndpointsInterface.
func (w *wrappedEndpoints) Apply(ctx context.Context, endpoints *coreapplyv1.EndpointsApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Endpoints, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, endpoints, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Events(namespace string) corev1.EventInterface {
	return &wrappedEvent{
		cluster:  w.cluster,
		delegate: w.delegate.Events(namespace),
	}
}

type wrappedEvent struct {
	cluster  logicalcluster.Name
	delegate corev1.EventInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedEvent. It errors when
// there is a mismatch.
func (w *wrappedEvent) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements EventInterface.
func (w *wrappedEvent) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Event, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements EventInterface.
func (w *wrappedEvent) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.EventList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements EventInterface.
func (w *wrappedEvent) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements EventInterface.
func (w *wrappedEvent) Create(ctx context.Context, event *coreapiv1.Event, opts metav1.CreateOptions) (*coreapiv1.Event, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, event, opts)
}

// Update implements EventInterface.
func (w *wrappedEvent) Update(ctx context.Context, event *coreapiv1.Event, opts metav1.UpdateOptions) (*coreapiv1.Event, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, event, opts)
}

// Delete implements EventInterface.
func (w *wrappedEvent) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements EventInterface.
func (w *wrappedEvent) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements EventInterface.
func (w *wrappedEvent) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Event, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements EventInterface.
func (w *wrappedEvent) Apply(ctx context.Context, event *coreapplyv1.EventApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Event, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, event, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) LimitRanges(namespace string) corev1.LimitRangeInterface {
	return &wrappedLimitRange{
		cluster:  w.cluster,
		delegate: w.delegate.LimitRanges(namespace),
	}
}

type wrappedLimitRange struct {
	cluster  logicalcluster.Name
	delegate corev1.LimitRangeInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedLimitRange. It errors when
// there is a mismatch.
func (w *wrappedLimitRange) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements LimitRangeInterface.
func (w *wrappedLimitRange) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.LimitRange, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements LimitRangeInterface.
func (w *wrappedLimitRange) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.LimitRangeList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements LimitRangeInterface.
func (w *wrappedLimitRange) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements LimitRangeInterface.
func (w *wrappedLimitRange) Create(ctx context.Context, limitRange *coreapiv1.LimitRange, opts metav1.CreateOptions) (*coreapiv1.LimitRange, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, limitRange, opts)
}

// Update implements LimitRangeInterface.
func (w *wrappedLimitRange) Update(ctx context.Context, limitRange *coreapiv1.LimitRange, opts metav1.UpdateOptions) (*coreapiv1.LimitRange, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, limitRange, opts)
}

// Delete implements LimitRangeInterface.
func (w *wrappedLimitRange) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements LimitRangeInterface.
func (w *wrappedLimitRange) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements LimitRangeInterface.
func (w *wrappedLimitRange) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.LimitRange, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements LimitRangeInterface.
func (w *wrappedLimitRange) Apply(ctx context.Context, limitRange *coreapplyv1.LimitRangeApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.LimitRange, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, limitRange, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Namespaces() corev1.NamespaceInterface {
	return &wrappedNamespace{
		cluster:  w.cluster,
		delegate: w.delegate.Namespaces(),
	}
}

type wrappedNamespace struct {
	cluster  logicalcluster.Name
	delegate corev1.NamespaceInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedNamespace. It errors when
// there is a mismatch.
func (w *wrappedNamespace) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements NamespaceInterface.
func (w *wrappedNamespace) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Namespace, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements NamespaceInterface.
func (w *wrappedNamespace) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.NamespaceList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements NamespaceInterface.
func (w *wrappedNamespace) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements NamespaceInterface.
func (w *wrappedNamespace) Create(ctx context.Context, namespace *coreapiv1.Namespace, opts metav1.CreateOptions) (*coreapiv1.Namespace, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, namespace, opts)
}

// Update implements NamespaceInterface.
func (w *wrappedNamespace) Update(ctx context.Context, namespace *coreapiv1.Namespace, opts metav1.UpdateOptions) (*coreapiv1.Namespace, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, namespace, opts)
}

// UpdateStatus implements NamespaceInterface. It was generated because the type contains a Status member.
func (w *wrappedNamespace) UpdateStatus(ctx context.Context, namespace *coreapiv1.Namespace, opts metav1.UpdateOptions) (*coreapiv1.Namespace, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, namespace, opts)
}

// Delete implements NamespaceInterface.
func (w *wrappedNamespace) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// Patch implements NamespaceInterface.
func (w *wrappedNamespace) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Namespace, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements NamespaceInterface.
func (w *wrappedNamespace) Apply(ctx context.Context, namespace *coreapplyv1.NamespaceApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Namespace, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, namespace, opts)
}

// ApplyStatus implements NamespaceInterface.
func (w *wrappedNamespace) ApplyStatus(ctx context.Context, namespace *coreapplyv1.NamespaceApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Namespace, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, namespace, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Nodes() corev1.NodeInterface {
	return &wrappedNode{
		cluster:  w.cluster,
		delegate: w.delegate.Nodes(),
	}
}

type wrappedNode struct {
	cluster  logicalcluster.Name
	delegate corev1.NodeInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedNode. It errors when
// there is a mismatch.
func (w *wrappedNode) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements NodeInterface.
func (w *wrappedNode) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Node, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements NodeInterface.
func (w *wrappedNode) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.NodeList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements NodeInterface.
func (w *wrappedNode) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements NodeInterface.
func (w *wrappedNode) Create(ctx context.Context, node *coreapiv1.Node, opts metav1.CreateOptions) (*coreapiv1.Node, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, node, opts)
}

// Update implements NodeInterface.
func (w *wrappedNode) Update(ctx context.Context, node *coreapiv1.Node, opts metav1.UpdateOptions) (*coreapiv1.Node, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, node, opts)
}

// UpdateStatus implements NodeInterface. It was generated because the type contains a Status member.
func (w *wrappedNode) UpdateStatus(ctx context.Context, node *coreapiv1.Node, opts metav1.UpdateOptions) (*coreapiv1.Node, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, node, opts)
}

// Delete implements NodeInterface.
func (w *wrappedNode) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements NodeInterface.
func (w *wrappedNode) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements NodeInterface.
func (w *wrappedNode) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Node, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements NodeInterface.
func (w *wrappedNode) Apply(ctx context.Context, node *coreapplyv1.NodeApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Node, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, node, opts)
}

// ApplyStatus implements NodeInterface.
func (w *wrappedNode) ApplyStatus(ctx context.Context, node *coreapplyv1.NodeApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Node, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, node, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) PersistentVolumes() corev1.PersistentVolumeInterface {
	return &wrappedPersistentVolume{
		cluster:  w.cluster,
		delegate: w.delegate.PersistentVolumes(),
	}
}

type wrappedPersistentVolume struct {
	cluster  logicalcluster.Name
	delegate corev1.PersistentVolumeInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedPersistentVolume. It errors when
// there is a mismatch.
func (w *wrappedPersistentVolume) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.PersistentVolume, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.PersistentVolumeList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Create(ctx context.Context, persistentVolume *coreapiv1.PersistentVolume, opts metav1.CreateOptions) (*coreapiv1.PersistentVolume, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, persistentVolume, opts)
}

// Update implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Update(ctx context.Context, persistentVolume *coreapiv1.PersistentVolume, opts metav1.UpdateOptions) (*coreapiv1.PersistentVolume, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, persistentVolume, opts)
}

// UpdateStatus implements PersistentVolumeInterface. It was generated because the type contains a Status member.
func (w *wrappedPersistentVolume) UpdateStatus(ctx context.Context, persistentVolume *coreapiv1.PersistentVolume, opts metav1.UpdateOptions) (*coreapiv1.PersistentVolume, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, persistentVolume, opts)
}

// Delete implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.PersistentVolume, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) Apply(ctx context.Context, persistentVolume *coreapplyv1.PersistentVolumeApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.PersistentVolume, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, persistentVolume, opts)
}

// ApplyStatus implements PersistentVolumeInterface.
func (w *wrappedPersistentVolume) ApplyStatus(ctx context.Context, persistentVolume *coreapplyv1.PersistentVolumeApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.PersistentVolume, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, persistentVolume, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) PersistentVolumeClaims(namespace string) corev1.PersistentVolumeClaimInterface {
	return &wrappedPersistentVolumeClaim{
		cluster:  w.cluster,
		delegate: w.delegate.PersistentVolumeClaims(namespace),
	}
}

type wrappedPersistentVolumeClaim struct {
	cluster  logicalcluster.Name
	delegate corev1.PersistentVolumeClaimInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedPersistentVolumeClaim. It errors when
// there is a mismatch.
func (w *wrappedPersistentVolumeClaim) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.PersistentVolumeClaim, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.PersistentVolumeClaimList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Create(ctx context.Context, persistentVolumeClaim *coreapiv1.PersistentVolumeClaim, opts metav1.CreateOptions) (*coreapiv1.PersistentVolumeClaim, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, persistentVolumeClaim, opts)
}

// Update implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Update(ctx context.Context, persistentVolumeClaim *coreapiv1.PersistentVolumeClaim, opts metav1.UpdateOptions) (*coreapiv1.PersistentVolumeClaim, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, persistentVolumeClaim, opts)
}

// UpdateStatus implements PersistentVolumeClaimInterface. It was generated because the type contains a Status member.
func (w *wrappedPersistentVolumeClaim) UpdateStatus(ctx context.Context, persistentVolumeClaim *coreapiv1.PersistentVolumeClaim, opts metav1.UpdateOptions) (*coreapiv1.PersistentVolumeClaim, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, persistentVolumeClaim, opts)
}

// Delete implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.PersistentVolumeClaim, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) Apply(ctx context.Context, persistentVolumeClaim *coreapplyv1.PersistentVolumeClaimApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.PersistentVolumeClaim, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, persistentVolumeClaim, opts)
}

// ApplyStatus implements PersistentVolumeClaimInterface.
func (w *wrappedPersistentVolumeClaim) ApplyStatus(ctx context.Context, persistentVolumeClaim *coreapplyv1.PersistentVolumeClaimApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.PersistentVolumeClaim, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, persistentVolumeClaim, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Pods(namespace string) corev1.PodInterface {
	return &wrappedPod{
		cluster:  w.cluster,
		delegate: w.delegate.Pods(namespace),
	}
}

type wrappedPod struct {
	cluster  logicalcluster.Name
	delegate corev1.PodInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedPod. It errors when
// there is a mismatch.
func (w *wrappedPod) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements PodInterface.
func (w *wrappedPod) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Pod, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements PodInterface.
func (w *wrappedPod) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.PodList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements PodInterface.
func (w *wrappedPod) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements PodInterface.
func (w *wrappedPod) Create(ctx context.Context, pod *coreapiv1.Pod, opts metav1.CreateOptions) (*coreapiv1.Pod, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, pod, opts)
}

// Update implements PodInterface.
func (w *wrappedPod) Update(ctx context.Context, pod *coreapiv1.Pod, opts metav1.UpdateOptions) (*coreapiv1.Pod, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, pod, opts)
}

// UpdateStatus implements PodInterface. It was generated because the type contains a Status member.
func (w *wrappedPod) UpdateStatus(ctx context.Context, pod *coreapiv1.Pod, opts metav1.UpdateOptions) (*coreapiv1.Pod, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, pod, opts)
}

// Delete implements PodInterface.
func (w *wrappedPod) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements PodInterface.
func (w *wrappedPod) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements PodInterface.
func (w *wrappedPod) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Pod, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements PodInterface.
func (w *wrappedPod) Apply(ctx context.Context, pod *coreapplyv1.PodApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Pod, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, pod, opts)
}

// ApplyStatus implements PodInterface.
func (w *wrappedPod) ApplyStatus(ctx context.Context, pod *coreapplyv1.PodApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Pod, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, pod, opts)
}

// UpdateEphemeralContainers implements PodInterface.
func (w *wrappedPod) UpdateEphemeralContainers(ctx context.Context, name string, pod *coreapiv1.Pod, opts metav1.UpdateOptions) (*coreapiv1.Pod, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateEphemeralContainers(ctx, name, pod, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) PodTemplates(namespace string) corev1.PodTemplateInterface {
	return &wrappedPodTemplate{
		cluster:  w.cluster,
		delegate: w.delegate.PodTemplates(namespace),
	}
}

type wrappedPodTemplate struct {
	cluster  logicalcluster.Name
	delegate corev1.PodTemplateInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedPodTemplate. It errors when
// there is a mismatch.
func (w *wrappedPodTemplate) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements PodTemplateInterface.
func (w *wrappedPodTemplate) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.PodTemplate, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements PodTemplateInterface.
func (w *wrappedPodTemplate) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.PodTemplateList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements PodTemplateInterface.
func (w *wrappedPodTemplate) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements PodTemplateInterface.
func (w *wrappedPodTemplate) Create(ctx context.Context, podTemplate *coreapiv1.PodTemplate, opts metav1.CreateOptions) (*coreapiv1.PodTemplate, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, podTemplate, opts)
}

// Update implements PodTemplateInterface.
func (w *wrappedPodTemplate) Update(ctx context.Context, podTemplate *coreapiv1.PodTemplate, opts metav1.UpdateOptions) (*coreapiv1.PodTemplate, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, podTemplate, opts)
}

// Delete implements PodTemplateInterface.
func (w *wrappedPodTemplate) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements PodTemplateInterface.
func (w *wrappedPodTemplate) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements PodTemplateInterface.
func (w *wrappedPodTemplate) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.PodTemplate, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements PodTemplateInterface.
func (w *wrappedPodTemplate) Apply(ctx context.Context, podTemplate *coreapplyv1.PodTemplateApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.PodTemplate, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, podTemplate, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) ReplicationControllers(namespace string) corev1.ReplicationControllerInterface {
	return &wrappedReplicationController{
		cluster:  w.cluster,
		delegate: w.delegate.ReplicationControllers(namespace),
	}
}

type wrappedReplicationController struct {
	cluster  logicalcluster.Name
	delegate corev1.ReplicationControllerInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedReplicationController. It errors when
// there is a mismatch.
func (w *wrappedReplicationController) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.ReplicationController, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ReplicationControllerInterface.
func (w *wrappedReplicationController) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ReplicationControllerList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Create(ctx context.Context, replicationController *coreapiv1.ReplicationController, opts metav1.CreateOptions) (*coreapiv1.ReplicationController, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, replicationController, opts)
}

// Update implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Update(ctx context.Context, replicationController *coreapiv1.ReplicationController, opts metav1.UpdateOptions) (*coreapiv1.ReplicationController, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, replicationController, opts)
}

// UpdateStatus implements ReplicationControllerInterface. It was generated because the type contains a Status member.
func (w *wrappedReplicationController) UpdateStatus(ctx context.Context, replicationController *coreapiv1.ReplicationController, opts metav1.UpdateOptions) (*coreapiv1.ReplicationController, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, replicationController, opts)
}

// Delete implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ReplicationControllerInterface.
func (w *wrappedReplicationController) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.ReplicationController, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ReplicationControllerInterface.
func (w *wrappedReplicationController) Apply(ctx context.Context, replicationController *coreapplyv1.ReplicationControllerApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ReplicationController, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, replicationController, opts)
}

// ApplyStatus implements ReplicationControllerInterface.
func (w *wrappedReplicationController) ApplyStatus(ctx context.Context, replicationController *coreapplyv1.ReplicationControllerApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ReplicationController, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, replicationController, opts)
}

// GetScale implements ReplicationControllerInterface.
func (w *wrappedReplicationController) GetScale(ctx context.Context, name string, opts metav1.GetOptions) (*scaleapi.Scale, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.GetScale(ctx, name, opts)
}

// UpdateScale implements ReplicationControllerInterface.
func (w *wrappedReplicationController) UpdateScale(ctx context.Context, name string, scale *scaleapi.Scale, opts metav1.UpdateOptions) (*scaleapi.Scale, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateScale(ctx, name, scale, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) ResourceQuotas(namespace string) corev1.ResourceQuotaInterface {
	return &wrappedResourceQuota{
		cluster:  w.cluster,
		delegate: w.delegate.ResourceQuotas(namespace),
	}
}

type wrappedResourceQuota struct {
	cluster  logicalcluster.Name
	delegate corev1.ResourceQuotaInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedResourceQuota. It errors when
// there is a mismatch.
func (w *wrappedResourceQuota) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.ResourceQuota, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ResourceQuotaList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Create(ctx context.Context, resourceQuota *coreapiv1.ResourceQuota, opts metav1.CreateOptions) (*coreapiv1.ResourceQuota, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, resourceQuota, opts)
}

// Update implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Update(ctx context.Context, resourceQuota *coreapiv1.ResourceQuota, opts metav1.UpdateOptions) (*coreapiv1.ResourceQuota, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, resourceQuota, opts)
}

// UpdateStatus implements ResourceQuotaInterface. It was generated because the type contains a Status member.
func (w *wrappedResourceQuota) UpdateStatus(ctx context.Context, resourceQuota *coreapiv1.ResourceQuota, opts metav1.UpdateOptions) (*coreapiv1.ResourceQuota, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, resourceQuota, opts)
}

// Delete implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.ResourceQuota, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) Apply(ctx context.Context, resourceQuota *coreapplyv1.ResourceQuotaApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ResourceQuota, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, resourceQuota, opts)
}

// ApplyStatus implements ResourceQuotaInterface.
func (w *wrappedResourceQuota) ApplyStatus(ctx context.Context, resourceQuota *coreapplyv1.ResourceQuotaApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ResourceQuota, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, resourceQuota, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Secrets(namespace string) corev1.SecretInterface {
	return &wrappedSecret{
		cluster:  w.cluster,
		delegate: w.delegate.Secrets(namespace),
	}
}

type wrappedSecret struct {
	cluster  logicalcluster.Name
	delegate corev1.SecretInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedSecret. It errors when
// there is a mismatch.
func (w *wrappedSecret) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements SecretInterface.
func (w *wrappedSecret) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Secret, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements SecretInterface.
func (w *wrappedSecret) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.SecretList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements SecretInterface.
func (w *wrappedSecret) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements SecretInterface.
func (w *wrappedSecret) Create(ctx context.Context, secret *coreapiv1.Secret, opts metav1.CreateOptions) (*coreapiv1.Secret, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, secret, opts)
}

// Update implements SecretInterface.
func (w *wrappedSecret) Update(ctx context.Context, secret *coreapiv1.Secret, opts metav1.UpdateOptions) (*coreapiv1.Secret, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, secret, opts)
}

// Delete implements SecretInterface.
func (w *wrappedSecret) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements SecretInterface.
func (w *wrappedSecret) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements SecretInterface.
func (w *wrappedSecret) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Secret, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements SecretInterface.
func (w *wrappedSecret) Apply(ctx context.Context, secret *coreapplyv1.SecretApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Secret, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, secret, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) Services(namespace string) corev1.ServiceInterface {
	return &wrappedService{
		cluster:  w.cluster,
		delegate: w.delegate.Services(namespace),
	}
}

type wrappedService struct {
	cluster  logicalcluster.Name
	delegate corev1.ServiceInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedService. It errors when
// there is a mismatch.
func (w *wrappedService) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ServiceInterface.
func (w *wrappedService) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.Service, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ServiceInterface.
func (w *wrappedService) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ServiceList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ServiceInterface.
func (w *wrappedService) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ServiceInterface.
func (w *wrappedService) Create(ctx context.Context, service *coreapiv1.Service, opts metav1.CreateOptions) (*coreapiv1.Service, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, service, opts)
}

// Update implements ServiceInterface.
func (w *wrappedService) Update(ctx context.Context, service *coreapiv1.Service, opts metav1.UpdateOptions) (*coreapiv1.Service, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, service, opts)
}

// UpdateStatus implements ServiceInterface. It was generated because the type contains a Status member.
func (w *wrappedService) UpdateStatus(ctx context.Context, service *coreapiv1.Service, opts metav1.UpdateOptions) (*coreapiv1.Service, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.UpdateStatus(ctx, service, opts)
}

// Delete implements ServiceInterface.
func (w *wrappedService) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// Patch implements ServiceInterface.
func (w *wrappedService) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.Service, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ServiceInterface.
func (w *wrappedService) Apply(ctx context.Context, service *coreapplyv1.ServiceApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Service, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, service, opts)
}

// ApplyStatus implements ServiceInterface.
func (w *wrappedService) ApplyStatus(ctx context.Context, service *coreapplyv1.ServiceApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.Service, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.ApplyStatus(ctx, service, opts)
}

// WrappedCoreV1 contains the wrapped logical cluster and interface.
func (w *WrappedCoreV1) ServiceAccounts(namespace string) corev1.ServiceAccountInterface {
	return &wrappedServiceAccount{
		cluster:  w.cluster,
		delegate: w.delegate.ServiceAccounts(namespace),
	}
}

type wrappedServiceAccount struct {
	cluster  logicalcluster.Name
	delegate corev1.ServiceAccountInterface
}

// checkCluster retrieves the logical cluster name from the given context and checks
// if it is the same as the one passed while creating a wrappedServiceAccount. It errors when
// there is a mismatch.
func (w *wrappedServiceAccount) checkCluster(ctx context.Context) (context.Context, error) {
	ctxCluster, ok := kcp.ClusterFromContext(ctx)
	if !ok {
		return kcp.WithCluster(ctx, w.cluster), nil
	} else if ctxCluster != w.cluster {
		return ctx, fmt.Errorf("cluster mismatch: context=%q, client=%q", ctxCluster, w.cluster)
	}
	return ctx, nil
}

// Get implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Get(ctx context.Context, name string, opts metav1.GetOptions) (*coreapiv1.ServiceAccount, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Get(ctx, name, opts)
}

// List implements ServiceAccountInterface.
func (w *wrappedServiceAccount) List(ctx context.Context, opts metav1.ListOptions) (*coreapiv1.ServiceAccountList, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.List(ctx, opts)
}

// Watch implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Watch(ctx, opts)
}

// Create implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Create(ctx context.Context, serviceAccount *coreapiv1.ServiceAccount, opts metav1.CreateOptions) (*coreapiv1.ServiceAccount, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Create(ctx, serviceAccount, opts)
}

// Update implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Update(ctx context.Context, serviceAccount *coreapiv1.ServiceAccount, opts metav1.UpdateOptions) (*coreapiv1.ServiceAccount, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Update(ctx, serviceAccount, opts)
}

// Delete implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.Delete(ctx, name, opts)
}

// DeleteCollection implements ServiceAccountInterface.
func (w *wrappedServiceAccount) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listopts metav1.ListOptions) error {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return err
	}
	return w.delegate.DeleteCollection(ctx, opts, listopts)
}

// Patch implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *coreapiv1.ServiceAccount, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Patch(ctx, name, pt, data, opts, subresources...)
}

// Apply implements ServiceAccountInterface.
func (w *wrappedServiceAccount) Apply(ctx context.Context, serviceAccount *coreapplyv1.ServiceAccountApplyConfiguration, opts metav1.ApplyOptions) (result *coreapiv1.ServiceAccount, err error) {
	ctx, err = w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.Apply(ctx, serviceAccount, opts)
}

// CreateToken implements ServiceAccountInterface.
func (w *wrappedServiceAccount) CreateToken(ctx context.Context, name string, tokenrequest *tokenrequestapi.TokenRequest, opts metav1.CreateOptions) (*tokenrequestapi.TokenRequest, error) {
	ctx, err := w.checkCluster(ctx)
	if err != nil {
		return nil, err
	}
	return w.delegate.CreateToken(ctx, name, tokenrequest, opts)
}
